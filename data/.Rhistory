demand = 0
#price must be set so supply == demand
#if we iterate without finding an answer for 100 times, just bail.
for(i in nrow(agents):1) {
#start at the most optimistic, assign them to demand
#if this agent's willingess to pay is lower than the price
#he is going to sell everything, so he does not contribute to demand
if(wtp[i] < p){
break
}
#now this unit will buy as much as possible, so demand is current amount
#plus amount purchased
if(allow_leverage){
demand = demand + agents[i,]$underlying + (agents[i,]$capital + agents[i,]$underlying * price_down)/p
} else {
demand = demand + agents[i,]$underlying + agents[i,]$capital / p
}
}
print(paste("demand:", demand, "supply:", supply, "price:", p))
#check if demand ~= supply
if(abs(demand/supply - 1.0) < .01) {
#good enough
break
} else {
#adjust p depending on how badly we missed
print("adjusting price...")
p = p * ((i + nrow(agents))/nrow(agents) + demand/supply) / ((i + nrow(agents))/nrow(agents) + 1)
}
}
print("willingness to pay:")
print(summary(wtp))
return(p)
}
invest <- function(agents, lookahead, allow_leverage, allow_short){
#we know supply == demand, so change the capital/underlying allocation
#of the agents according to price
price_up = get_price(agents, 1, 0, lookahead-1, allow_leverage, allow_short)
price_down = get_price(agents, 0, 1, lookahead-1, allow_leverage, allow_short)
current_price = get_price(agents, 0, 0, lookahead, allow_leverage, allow_short)
#each person has own willingness to pay
wtp <- price_up * agents$probability + price_down *(1 - agents$probability)
print(summary(wtp))
remaining_supply = sum(agents$underlying)
for(i in nrow(agents):1) {
#start at the most optimistic, assign them to demand
#if this agent's willingess to pay is lower than the price, bail
if(wtp[i] < current_price){
if(remaining_supply != 0) {
#this is the unlucky person on the margin.  He has to keep some underlying
agents[i,]$underlying = agents[i,]$underlying + remaining_supply
agents[i,]$capital = agents[i,]$capital - current_price * remaining_supply
remaining_supply = 0
} else {
#these people sold their underlying this period
agents[i,]$capital = agents[i,]$capital + agents[i,]$underlying * current_price
agents[i,]$underlying = 0
}
}
else {
if(allow_leverage){
#buy as much as you can
agents[i,]$underlying = agents[i,]$underlying + (agents[i,]$capital + agents[i,]$underlying * price_down)/current_price
agents[i,]$capital = -agents[i,]$underlying * price_down
remaining_supply = remaining_supply - agents[i,]$underlying
} else {
agents[i,]$underlying = agents[i,]$underlying + agents[i,]$capital/current_price
agents[i,]$capital = 0
remaining_supply = remaining_supply - agents[i,]$underlying
}
}
}
return(agents)
}
count = 100
agents = data.frame(
probability=seq(from=0 + 1/count,to=1-1/count,length.out=count-1),
capital=1,
underlying=1
)
summary(agents)
iterations = 1
price_lookahead = 1
allow_leverage = FALSE
allow_short = FALSE
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
print(p)
a = invest(agents, price_lookahead, FALSE, FALSE)
summary(a)
a
mean(a$underlying)
mean(a$capital)
# for(i in 1:iterations){
#
#   #price is set by supply and demand
#   p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
#   print(p)
#
#   #bankrupt agents leave the market
#   agents = agents[(agents$capital + p * agents$underlying) > 0,]
#   #note that if an agent goes bankrupt, they can take losses with them,
#   #and capital goes up in the market
#
#   #agents choose investment based on their own beliefs
#   agents = invest(agents, price, allow_leverage, allow_short)
# }
print(p)
count = 1000
agents = data.frame(
probability=seq(from=0 + 1/count,to=1-1/count,length.out=count-1),
capital=1,
underlying=1
)
summary(agents)
iterations = 1
price_lookahead = 1
allow_leverage = FALSE
allow_short = FALSE
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
print(p)
a = invest(agents, price_lookahead, FALSE, FALSE)
print(p)
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
999/1006
1-999/1006
terminal_value <- function (up_count, down_count){
result = 1
if(up_count == 0){
result = 0.3
}
return(result)
}
get_price <- function(agents, up_count, down_count, lookahead, allow_leverage, allow_short){
if(lookahead == 0)
{
return(terminal_value(up_count, down_count))
}
#recursively figure out up state value, down state value
price_up = get_price(agents, up_count + 1, down_count, lookahead-1, allow_leverage, allow_short)
price_down = get_price(agents, up_count, down_count + 1, lookahead-1, allow_leverage, allow_short)
print(paste("price up:", price_up))
print(paste("price down:", price_down))
if(abs(price_up / price_down - 1.0) < .0001) {
#prices are too close together; everyone is going to want the same thing,
#and our optimization process is going to fail.  Just return the mean of the two.
#this often happens if price_up == price_down
return((price_up + price_down)/2.0)
}
#each person has own willingness to pay
wtp <- price_up * agents$probability + price_down *(1 - agents$probability)
#make sure agents are sorted
agents = agents[order(agents$probability),]
#initial price seed
p = mean(wtp)
MAX = 100
for(j in 1:MAX) {
#supply is total numer of underlyings in the market
supply = sum(agents$underlying)
#demand is total amount owned by people who want it
demand = 0
#price must be set so supply == demand
#if we iterate without finding an answer for 100 times, just bail.
for(i in nrow(agents):1) {
#start at the most optimistic, assign them to demand
#if this agent's willingess to pay is lower than the price
#he is going to sell everything, so he does not contribute to demand
if(wtp[i] < p){
break
}
#now this unit will buy as much as possible, so demand is current amount
#plus amount purchased
if(allow_leverage){
demand = demand + agents[i,]$underlying + (agents[i,]$capital + agents[i,]$underlying * price_down)/p
} else {
demand = demand + agents[i,]$underlying + agents[i,]$capital / p
}
}
print(paste("demand:", demand, "supply:", supply, "price:", p))
#check if demand ~= supply
if(abs(demand/supply - 1.0) < .01) {
#good enough
break
} else {
#adjust p depending on how badly we missed
print("adjusting price...")
p = p * ((i + nrow(agents))/nrow(agents) + demand/supply) / ((i + nrow(agents))/nrow(agents) + 1)
}
}
print("willingness to pay:")
print(summary(wtp))
return(p)
}
invest <- function(agents, lookahead, allow_leverage, allow_short){
#we know supply == demand, so change the capital/underlying allocation
#of the agents according to price
price_up = get_price(agents, 1, 0, lookahead-1, allow_leverage, allow_short)
price_down = get_price(agents, 0, 1, lookahead-1, allow_leverage, allow_short)
current_price = get_price(agents, 0, 0, lookahead, allow_leverage, allow_short)
#each person has own willingness to pay
wtp <- price_up * agents$probability + price_down *(1 - agents$probability)
print(summary(wtp))
remaining_supply = sum(agents$underlying)
for(i in nrow(agents):1) {
#start at the most optimistic, assign them to demand
#if this agent's willingess to pay is lower than the price, bail
if(wtp[i] < current_price){
if(remaining_supply != 0) {
#this is the unlucky person on the margin.  He has to keep some underlying
agents[i,]$underlying = agents[i,]$underlying + remaining_supply
agents[i,]$capital = agents[i,]$capital - current_price * remaining_supply
remaining_supply = 0
} else {
#these people sold their underlying this period
agents[i,]$capital = agents[i,]$capital + agents[i,]$underlying * current_price
agents[i,]$underlying = 0
}
}
else {
if(allow_leverage){
#buy as much as you can
agents[i,]$underlying = agents[i,]$underlying + (agents[i,]$capital + agents[i,]$underlying * price_down)/current_price
agents[i,]$capital = -agents[i,]$underlying * price_down
remaining_supply = remaining_supply - agents[i,]$underlying
} else {
agents[i,]$underlying = agents[i,]$underlying + agents[i,]$capital/current_price
agents[i,]$capital = 0
remaining_supply = remaining_supply - agents[i,]$underlying
}
}
}
return(agents)
}
count = 1000
agents = data.frame(
probability=seq(from=0 + 1/count,to=1-1/count,length.out=count-1),
capital=1,
underlying=1
)
summary(agents)
iterations = 1
price_lookahead = 1
allow_leverage = FALSE
allow_short = FALSE
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
print(p)
a = invest(agents, price_lookahead, FALSE, FALSE)
summary(a)
a
mean(a$underlying)
mean(a$capital)
# for(i in 1:iterations){
#
#   #price is set by supply and demand
#   p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
#   print(p)
#
#   #bankrupt agents leave the market
#   agents = agents[(agents$capital + p * agents$underlying) > 0,]
#   #note that if an agent goes bankrupt, they can take losses with them,
#   #and capital goes up in the market
#
#   #agents choose investment based on their own beliefs
#   agents = invest(agents, price, allow_leverage, allow_short)
# }
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
terminal_value <- function (up_count, down_count){
result = 1
if(up_count == 0){
result = 0.3
}
return(result)
}
get_price <- function(agents, up_count, down_count, lookahead, allow_leverage, allow_short){
if(lookahead == 0)
{
return(terminal_value(up_count, down_count))
}
#recursively figure out up state value, down state value
price_up = get_price(agents, up_count + 1, down_count, lookahead-1, allow_leverage, allow_short)
price_down = get_price(agents, up_count, down_count + 1, lookahead-1, allow_leverage, allow_short)
print(paste("price up:", price_up))
print(paste("price down:", price_down))
if(abs(price_up / price_down - 1.0) < .001) {
#prices are too close together; everyone is going to want the same thing,
#and our optimization process is going to fail.  Just return the mean of the two.
#this often happens if price_up == price_down
return((price_up + price_down)/2.0)
}
#each person has own willingness to pay
wtp <- price_up * agents$probability + price_down *(1 - agents$probability)
#make sure agents are sorted
agents = agents[order(agents$probability),]
#initial price seed
p = mean(wtp)
MAX = 100
for(j in 1:MAX) {
#supply is total numer of underlyings in the market
supply = sum(agents$underlying)
#demand is total amount owned by people who want it
demand = 0
#price must be set so supply == demand
#if we iterate without finding an answer for 100 times, just bail.
for(i in nrow(agents):1) {
#start at the most optimistic, assign them to demand
#if this agent's willingess to pay is lower than the price
#he is going to sell everything, so he does not contribute to demand
if(wtp[i] < p){
break
}
#now this unit will buy as much as possible, so demand is current amount
#plus amount purchased
if(allow_leverage){
demand = demand + agents[i,]$underlying + (agents[i,]$capital + agents[i,]$underlying * price_down)/p
} else {
demand = demand + agents[i,]$underlying + agents[i,]$capital / p
}
}
print(paste("demand:", demand, "supply:", supply, "price:", p))
#check if demand ~= supply
if(abs(demand/supply - 1.0) < .001) {
#good enough
break
} else {
#adjust p depending on how badly we missed
print("adjusting price...")
p = p * ((i + nrow(agents))/nrow(agents) + demand/supply) / ((i + nrow(agents))/nrow(agents) + 1)
}
}
print("willingness to pay:")
print(summary(wtp))
return(p)
}
invest <- function(agents, lookahead, allow_leverage, allow_short){
#we know supply == demand, so change the capital/underlying allocation
#of the agents according to price
price_up = get_price(agents, 1, 0, lookahead-1, allow_leverage, allow_short)
price_down = get_price(agents, 0, 1, lookahead-1, allow_leverage, allow_short)
current_price = get_price(agents, 0, 0, lookahead, allow_leverage, allow_short)
#each person has own willingness to pay
wtp <- price_up * agents$probability + price_down *(1 - agents$probability)
print(summary(wtp))
remaining_supply = sum(agents$underlying)
for(i in nrow(agents):1) {
#start at the most optimistic, assign them to demand
#if this agent's willingess to pay is lower than the price, bail
if(wtp[i] < current_price){
if(remaining_supply != 0) {
#this is the unlucky person on the margin.  He has to keep some underlying
agents[i,]$underlying = agents[i,]$underlying + remaining_supply
agents[i,]$capital = agents[i,]$capital - current_price * remaining_supply
remaining_supply = 0
} else {
#these people sold their underlying this period
agents[i,]$capital = agents[i,]$capital + agents[i,]$underlying * current_price
agents[i,]$underlying = 0
}
}
else {
if(allow_leverage){
#buy as much as you can
agents[i,]$underlying = agents[i,]$underlying + (agents[i,]$capital + agents[i,]$underlying * price_down)/current_price
agents[i,]$capital = -agents[i,]$underlying * price_down
remaining_supply = remaining_supply - agents[i,]$underlying
} else {
agents[i,]$underlying = agents[i,]$underlying + agents[i,]$capital/current_price
agents[i,]$capital = 0
remaining_supply = remaining_supply - agents[i,]$underlying
}
}
}
return(agents)
}
count = 1000
agents = data.frame(
probability=seq(from=0 + 1/count,to=1-1/count,length.out=count-1),
capital=1,
underlying=1
)
summary(agents)
iterations = 1
price_lookahead = 1
allow_leverage = FALSE
allow_short = FALSE
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
print(p)
a = invest(agents, price_lookahead, FALSE, FALSE)
summary(a)
a
mean(a$underlying)
mean(a$capital)
# for(i in 1:iterations){
#
#   #price is set by supply and demand
#   p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
#   print(p)
#
#   #bankrupt agents leave the market
#   agents = agents[(agents$capital + p * agents$underlying) > 0,]
#   #note that if an agent goes bankrupt, they can take losses with them,
#   #and capital goes up in the market
#
#   #agents choose investment based on their own beliefs
#   agents = invest(agents, price, allow_leverage, allow_short)
# }
print(p)
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
price_lookahead = 2
allow_leverage = FALSE
allow_short = FALSE
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
print(p)
a = invest(agents, price_lookahead, FALSE, FALSE)
summary(a)
a
count = 100
agents = data.frame(
probability=seq(from=0 + 1/count,to=1-1/count,length.out=count-1),
capital=1,
underlying=1
)
summary(agents)
iterations = 1
price_lookahead = 2
allow_leverage = FALSE
allow_short = FALSE
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
print(p)
a = invest(agents, price_lookahead, FALSE, FALSE)
summary(a)
a
print(p)
mean(a$underlying)
mean(a$capital)
p = get_price(agents, 0, 0, price_lookahead, allow_leverage, allow_short)
library("devtools")
library(roxygen2)
setwd("~/github/ml-lab")
document()
document()
?document
setwd("~/github/jml")
document()
Project = "~/github"
path= "/ml-lab/data"
setwd(paste(Project, path, sep=""))
library(data.table)
library(ggplot2)
library("devtools")
install_github('jakewalker56/jml', force = TRUE)
roc
?roc
position_offset = c(5, 10, 20, 50, 75, 100)
n = 150
iterations = 500
bad_passenger_array = c(list(1:2), list(1:3), list(1:4), list(1:5), list(1:10), list(1:30))
table_data = data.frame(bad_passenger_count=vector(),offset_coefficient=vector(),log_offset_coefficient=vector(), intercept=vector())
logframe_offset = list()
logframe_bad_passengers = list()
logframe_result = list()
for(bad_passengers in bad_passenger_array) {
bad_passengers = unlist(bad_passengers)
result = data.frame(n=vector(), p=vector(), prob=vector())
#we construct these as lists because rbind is computationally expensive; instead
#we just rbind them once at the end
for(offset in position_offset) {
final_person_seats = vector()
position_of_interest = n + 1 - offset
for(iteration in 1:iterations){
seat_taken_array = rep(0, n)
seat_occupied_by_array = rep(0,n)
remaining_seats_array = seq(1, n, length.out=n)
sample(remaining_seats_array, 1)
for(i in 1:n) {
if(i %in% bad_passengers || seat_occupied_by_array[i] != 0){
#bad_passengers and people whos seats have been taken select a random unclaimed seat
random_seat = sample(remaining_seats_array[remaining_seats_array != 0], 1)
seat_taken_array[i] = random_seat
seat_occupied_by_array[random_seat] = i
remaining_seats_array[random_seat] = 0
} else {
#good passengers take their own seat
seat_taken_array[i] = i
seat_occupied_by_array[i] = i
remaining_seats_array[i] = 0
}
}
#let's see which seen person n is in:
final_person_seats = c(final_person_seats, seat_taken_array[position_of_interest])
logframe_offset = c(logframe_offset, offset)
logframe_bad_passengers = c(logframe_bad_passengers, length(bad_passengers))
logframe_result = c(logframe_result, seat_taken_array[position_of_interest] == position_of_interest)
}
}
}
logframe_offset = unlist(logframe_offset)
logframe_bad_passengers = unlist(logframe_bad_passengers)
logframe_result = unlist(logframe_result)
logframe = data.frame(offset=logframe_offset, bad_passengers=logframe_bad_passengers, result=logframe_result)
logframe$log_offset = log(logframe$offset)
logframe$log_bad_passengers = log(logframe$bad_passengers)
#build a logistic model to predict probability
reg = glm(result ~ offset + log_offset + bad_passengers + log_bad_passengers, family="binomial", data=logframe)
summary(reg)
length(logframe)
nrow(logframe)
attributes(reg)
reg$deviance/reg$null.deviance
roc(0.1, reg$fitted)
roc
roc(predict(reg, logframe), logframe$result)
abline(a=0,b=1,lty=2,col=8)
roc(predict(reg, logframe), logframe$result, ylim=c(0,1))
roc(predict(reg, logframe), logframe$result, ylim=c(0,1), xlim=c(0,1))
